# 改进一下
#1. 先拉取数据，之后做截取工作，增加效率，同样的策略，速度较第二版框架快20多倍。
#2. 增加程序用时提示
#3. 先增加是否允许做空的参数，之后再在下一版中修改函数
#4. 将benchmark先暂且删除，因为可能和evaluate合并
import pandas as pd  
import numpy as np
import matplotlib.pyplot as plt
from pylab import mpl
from K_draw import *
import tafunction as taf
import math
import os
import datetime
from Get_data import *
import evaluate_strategy as es 


plt.rcParams['font.sans-serif']=['SimHei']
plt.rcParams['axes.unicode_minus'] = False

today = str(datetime.datetime.now().year) + '-' + str(datetime.datetime.now().month) + '-' + str(datetime.datetime.now().day)
#另一种写法 import time   
#today=time.strftime('%Y-%m-%d',time.localtime(time.time()))


class Strategy():
    
    def __init__(self):
        
        self.index = 0 
        self.data_all = []
        
    def set_account(self,capital=10000000,commission=0.0002,slippage=0.0002):
        
        self.capital_base = capital
        self.commission = commission
        self.slippage = slippage                   #滑点的计算方法应该可以和其他函数相关，之后可以修改
        
    def set_para(self,freq='day',start='1991-01-01',end=today,fq='qfq',allowshort=True):
        
        self.start = start
        self.end = end
        self.freq = freq
        self.fq = fq
        self.allowshort = allowshort
        data = get_k_data('index000001', self.start, self.end, self.freq, self.fq)
        self.len = len(data)                                                            #获取总长度的区间，但其实也可以不用提前获取
        #self.portfolio[self.code] = 0
        
    def set_universe(self,universe_list):
        
        self.universe = universe_list             #这里要额外定义一个get_index_universise，用以获取指数成分股列表
        self.portfolio = pd.DataFrame(columns=self.universe)
        for item in self.universe:                #提前把所有数据都获取了会不会更快点？
            self.data_all.append(get_k_data(item, self.start, self.end, self.freq, self.fq))
    
    def set_benchmark(self,benchmark='index000300'):
        self.benchmark = benchmark
        self.benchmark_data = self.get_k_data(self.benchmark, self.freq, self.start, self.end, self.fq)
    
    def handle_data(self):
        
        #首先获取数据，利用Get_data.py里的函数
        #code 使用循环时候获取的self.code
        
        for i in range(len(self.universe)):
            self.code = self.universe[i]
            self.data = self.data_all[i][:self.index+1]
        
            #这里其实要改进啊，如果循环的时候每天都获取一次全部数据，再全部计算，实际上很消耗时间和空间
            #应该把self.end设置成根据self.index移动的，或者就直接利用self.index，因此需要再写一个函数

            #根据自己的策略来进行操作，self.index用来循环表示回测窗口
            #这里还没能把self.index取代掉，实际使用的时候应该最好把self.index去掉

            '''
            signal = 1 
            '''
            df2 = self.data.copy()
            df2 = taf.MACD(df2)
            if df2.at[self.index,'MACDdiff_12_26'] > 0:
                self.Order_buy(100)
            elif df2.at[self.index,'MACDdiff_12_26'] < 0:
                self.Order_sell(100)
            else:
                self.Remain()
            # self.Order_buy(amount)
            # self.Order_to()
            '''
            signal = 0 
            '''
            # self.Order_sell()
            # self.Order_to()

    def Order_buy(self,amount):
        
        #还没有加判断条件，比如钱够不够，暂时不考虑这种情况
        #如果不能做空，可能还要考虑pofolio的仓位
        
        self.capital_base = self.capital_base - amount * self.data.close[self.index] * (1 + self.commission + self.slippage)       
        
        if self.index == 0:
            self.portfolio.loc[self.data.date[self.index], self.code] = amount 
        else:
            self.portfolio.loc[self.data.date[self.index], self.code] = self.portfolio.loc[self.data.date[self.index-1], self.code] + amount 
        
    def Order_sell(self,amount):

        self.capital_base = self.capital_base + amount * self.data.close[self.index]   
        
        #if 允许做空：
            #self.portfolio.loc[self.data.date[self.index], self.code] = amount 
        #else:
        self.portfolio.loc[self.data.date[self.index], self.code] = self.portfolio.loc[self.data.date[self.index-1], self.code] - amount 
    
    def Remain(self):
        
        if self.index == 0:
            self.portfolio.loc[self.data.date[self.index], self.code] = 0
        else:
            self.portfolio.loc[self.data.date[self.index], self.code] = self.portfolio.loc[self.data.date[self.index-1], self.code]
    
    def Order_to(self,amount):
        
        if amount > self.portfolio.loc[self.data.date[self.index-1], self.code]:
            self.capital_base = self.capital_base - (amount-self.portfolio.loc[self.data.date[self.index-1], self.code]) * self.data.close[self.index] * (1 + self.commission + self.slippage)
        else:
            self.capital_base = self.capital_base - (amount-self.portfolio.loc[self.data.date[self.index-1], self.code]) * self.data.close[self.index]
            
        self.portfolio.loc[self.data.date[self.index], self.code] == amount
    
    def run(self):                         
        
        start = time.clock()
        money = []                         #设置账户资产总额
   
        while self.index < self.len:    #从第一天开始    这里self.data要重新开始
            
            self.handle_data()             #是否进行该股票的买卖

            money.append(self.capital_base) #先不计算总的账户资产额度（没有增加市值)

            self.index += 1 

        self.money = pd.Series(money)
        end = time.clock()
        print('Running time: %s Seconds'%(end-start))
        
    def evaluate_strategy(self):
        
        date_list = self.data.date
        es.get_return(self.money,self.index_list)
        
if __name__ == '__main__':
  MACD = Strategy()
  MACD.set_account()
  MACD.set_para(freq='day',start='2018-01-01',end='2020-01-01',fq='qfq',allowshort=True)
  MACD.set_universe(['000001','000002'])
  MACD.run()

